(**
   TEST PLAN: 
   - OUnit vs Manual tests are broken into 2 sections. 
   - Explanation of the development of test cases is structured by file.
   - Argument for demonstrating the correctness of our system is also separated
     by file.


   A) OUNIT TESTS: 
      All OUnit Tests were checked for over 90% coverage through make bisect.

   - [board.ml]
     Test cases were created on all public functions of [board.ml] through glass
     box testing. We passed inputs of boards generated by txt files, positions 
     on the board, and generated pieces.

     This demonstrates correctness as all public functions of [board.ml] are
     tested for their success and failure returns and all basic board operations
     function correctly.

   - [command.ml]
     Test cases were created on the public function [parse] by either:
     1. Passing inputs that completely follow instructions to spec for each and
     every type of command. 
     2. Passing inputs that didn't completely follow insructions to spec but 
     would still pass as valid commands, (ie. correct commands containing 
     random amounts of whitespace)

     We also did manual tests to check the feedback from the exceptions raised
     in [command.ml].
     MANUAL TESTS (in start menu):
     1. (Entering nothing) -> Invalid command. 
     2. start -> Invalid command. Try: 'Start <timer>'.
     3. view -> Invalid command. Try: 'View instructions'.
     MANUAL TESTS (in game):
     4. move -> Invalid command. 
     5. move 10 -> Invalid command. 
     6. move i 2 b 4 -> Column not found.
     7. move h 2 1 3 -> Column not found.  
     6. move a b a 4 -> Row not found.
     7. move a 2 a 9 -> Row not found.

     This demonstrates correctness as all types of correct and incorrect
     inputs were tested for [parse]. All different commands and their 
     variations were tested, as well as all of the various exceptions were 
     raised with incorrect inputs.

   - [move.ml]
     Test cases were created on all public functions of [move.ml] either:
     1. By passing inputs representative of the same, vertical, horizontal,
        diagonal, or non-related positions.
     2. By passing inputs in addition to (1) which checks extra computations 
        involved. (ie. King can only move one step at a time, or pawn can move
        two steps if taking its first step)
     Note that [is_valid_basic_move] which checks the basic movement of all
     pieces (not considering capturing) has such tests applied per possible
     rank.

     This demonstrates correctness as the expected boolean outputs of [move.ml]
     are checked for both true and false, and expected basic moves are checked
     by rank.

   - [piece.ml]
     Test cases were created on all public functions of [piece.ml] either:
     1. By involving all possible inputs, if not many exist (ie. a single 
        parameter of Piece.rank would result in 6 possible inputs, Pawn, Rook,
        Bishop, Knight, King, or Queen).
     2. By glass-box testing, to cover all possible structure of outputs, if
        there are an infinite / many possible inputs.

     This demonstrates correctness as all public functions of [piece.ml] are 
     tested upon equality for expected outputs using strategically varied 
     inputs, and such functions in [piece.ml] are used as building blocks to
     the system in numerous files.

   - [state.ml] CHECKMATE:
     Checkmate was tested by running our checkmate algorithm on the 33 most 
     common checkmate patterns (exact link to boards noted in testCheckmate.ml).
     For each of these board patterns, we manually wrote up a board to represent
     it as a txt file (located in the boards/checkmate/<directory>) and loaded 
     it into our checkmate algorithm. While there is an incredibly large number 
     of possible board configurations that could result in a checkmate, we 
     believe that this method demonstrates the algorithms correctness and covers 
     the widest range of patterns available to our knowledge. Our boards test 
     the minimal number of pieces needed for a checkmate in a given pattern, 
     testing the essential factors involved in deeming a checkmate. We also test
     that our checkmate algorithm does not prematurely deem "check" situations 
     as a "checkmate" manually.

   - [state.ml] OTHER FUNCTIONS:
     Glass box testing was used to create Test cases for all public functions:
     1. [cmp_state] was tested by inputing both equivalent and unequivalent 
     states to make sure it returned the correct output. 
     2. [init_state] was tested by comparing it with [cmp_state] to a manually
     created default state. 
     3. [cmp_boards] was tested by inputing both equivalent and unequivalent 
     boards to make sure it returned the correct output. 
     4. [get_board] was tested by testing [cmp_boards]. 
     5. [get_turn] was tested on the first move and several following moves.
     6. [get_last_update] was tested by moving, castling, en passant capture, 
     promoting, etc. and making sure the last_update was correct. 
     7. [set_update] was tested by setting a custom update and testing it 
     using [get_last_update].
     8. [set_board] was tested by manually creating and setting boards and 
     comparing them to the board created by [init_state].
     9. [move] was tested by moving various pieces to various positions and
     comparing their states/boards afterwards. Move rulesets were tested in
     testing for [move.ml].
     10. [castle] was tested by executing all types of castling and comparing
     their last_update messages.
     11. [count_graveyard_piece] was tested by capturing pieces and seeing 
     whether the graveyard piece counts would update. 
     12. [can_promote] was tested by checking the position of a pawn before and
     and after its promotion. 
     13. [promote] was tested by testing [is_in_promotion].
     14. [set_state] was tested by moving, castling, and then comparing boards,
     updates, etc.
     15. [is_in_promotion] was tested before, during, and after promotion of a
     pawn for both teams to various different pieces.

     This demonstrates correctness because every function in [state.ml] was 
     given varied inputs to ensure that testing exhausted all possible
     outcomes. Testing for Exceptions raised was not included [state.ml] 
     because the exceptions for [state.ml] have been caught and tested in other
     files.


   B) MANUAL TESTS:

   - [gui.ml] is tested manually by inputting possible valid and invalid 
     commands into the terminal. The valid commands that involve [gui.ml] are:
     1. make play (executes [print_onboarding])
     2. quit (executes [print_quit])
     3. start 300 (executes [print_board])
     4. move c1 r1 c2 r2 (executes [print_time_end] if moving a piece from 
        (c1, r1) to (c2, r2) is a valid move when playing the game, and a player
        has run out of time for moving.)
     5. checkmate (executes [print_checkmate], did this for both when in check
         and not in check)
     6. view instructions 
        (executes [print_instructions] and [print_instructions_page])
     7. next (executes [print_special_moves])
     8. back (check correctness of movement between instruction pages)

     This demonstrates correctness because the public functions of [gui.ml] 
     only contain print functions that must be checked in the terminal, and the 
     commands executed cover all possible printings of [gui.ml]. We also tested 
     random commands to make sure that the invalid commands are caught and 
     corresponding feedback is provided to the player.

   - [translate.ml] is tested manually through [main.ml], using the same tests
     of [main.ml].

     This demonstrates correctness because [translate.ml] provides [main.ml] 
     helper functions that are reflected through [main.ml]'s printing.

   - [main.ml] is tested manually by inputting possible valid and invalid
     commands into the terminal. The valid commands that involve [main.ml]
     include:
     1. All valid commands involving [gui.ml] above.
     2. Any move, castle, help, or make command.

     This demonstrates correctness as we were able to evaluate the printing 
     results of the terminal, and user input.
     > move: Both valid and invalid moves were tested, to qualitatively check
      that state is not changed for an invalid move, though it is changed for
      a valid move, with any side effects of capturing reflected in the
      board and graveyards printed.
     > castle: Both valid and invalid moves were tested similarly to move.
     > help: Called help within different states to check for correct feedback.
      ie. will have different feedback for a state being in promotion (pawn can 
      be promoted to a different rank) than not in promotion.
     > make: Both valid and invalid ranks were tested, to make sure that a pawn
     can be changed to any higher rank except for king.
*)

open OUnit2

(* Tests for all public functions in piece.ml. *)
let piece_tests = List.flatten [
    TestPiece.basic_piece_tests;
    TestPiece.check_piece_tests;
    TestPiece.piece_get_tests;
    TestPiece.string_piece_tests;
  ]

(* Tests for all public functions in move.ml. *)
let basic_move_check_tests = List.flatten [
    TestMove.basic_move_tests; 
    TestMove.basic_valid_move_tests;
    TestMove.basic_valid_castle_tests;
  ]

(* Tests for all public functions in board.ml. *)
let board_tests = List.flatten [
    TestBoard.board_operation_tests;
    TestBoard.board_structure_tests;
    TestBoard.clear_paths_tests;
  ]

(* Tests for all check and checkmate functions in state.ml. *)
let checkmate_tests = List.flatten [
    TestCheckmate.check_tests;
    TestCheckmate.checkmate_tests;
    TestCheckmate.non_checkmate_tests;
  ]

(* Tests for all other public functions in state.ml. *)
let state_tests = List.flatten [
    TestState.state_tests;
  ]

(* Tests for all public functions in command.ml. *)
let command_tests = List.flatten [
    TestCommand.valid_parse_tests;
    TestCommand.invalid_parse_tests;
  ]

let tests = List.flatten [
    checkmate_tests;
    board_tests;
    command_tests;
    basic_move_check_tests;
    piece_tests;
    state_tests;
  ]

let suite = "test suite for Chess" >::: tests
let _ = run_test_tt_main suite